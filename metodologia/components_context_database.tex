\subsection{Context database}
As we have stated in both the \textbf{LPIP} and \textbf{ASR} section, it is crucial that our instruction building process (first being correctly recognized, then being correctly built) is resilient.
In case of a wrong transcription, an ideal scenario would involve our LPIP (Small Language Model) being able to correct the transcription using its judgement. For this, we introduce the Context Database.

This component functions as the LPIP's memory. In the domain of Language Models, this technique is a simplified form of \textbf{Retrieval-augmented generation}~\cite{rag}. It will provide our LPIP with contextual data preventing it from hallucinating and adding a resilience layer.

The absence of this component would mean the LPIP operates in the dark, with no information of the simulation state at the time of generating the instructions or the response. Without contextual data, instructions
without a callsign would not have any aircraft to be directed to, as the LPIP would not be able to infer from just the transcription the last aircraft to which an instruction was directed. This is only one amongst
the many problems the Context Database helps solve.

Another scenario is one where the ASR module has mistakenly transcribed an audio fragment. This could look something like \texttt{IBERIA two nine true (\ldots)}. Without a contextual database, the LPIP
could mistakenly assume the callsign to be something erroneous. However, given that the Contextual Database injects context data containing the callsigns of the available aircrafts (\texttt{"IBERIA292", "LUXAIR331"}), the SLM
will perform a \textbf{phonetic match} between its transcription and the only possible data.

\subsubsection{Implementation, data structures, update loop and final prompt}
Using an actual database, like Redis or an SQL-based database, seems like overkill. We need a lightweight agent which operates with fast updates and fast reads. We don't need it to be persistent, so we will be using a Python dictionary database.
Each of its elements will be a serializable object.

This database will hold \textbf{Aircraft} elements. The key will be their callsign. Each of these aircrafts will contain certain attributes:

\begin{enumerate}
	\item \textbf{Current state:} Aircraft's altitude, heading, speed, latitude and longitude
	\item \textbf{Last known instruction:} Last instruction to have been sent to this aircraft.
	\item \textbf{Last instruction was successful:} Either true or false.
\end{enumerate}

This contextual database is dynamic, and updated as described in Figure~\ref{fig:full-auto-pseudopilot}. The \textbf{PIEM} (Pseudo-pilot Instruction Execution Module) is responsible for updating this database every time the Flight Simulation interface
provides feedback on the instructions.

This architecture ensures the LPIP always has access to the most up-to-date information, allowing it to further improve its resilient architecture. All in all, the prompt directed to the Small Language Model ends up being something like~\ref{lst:system-prompt-updated} (complementing \ref{lst:system-prompt})

\begin{lstlisting}[language=json, caption={System Prompt for LPIP, updated with }, label={lst:system-prompt-updated}]
    [INITIAL INSTRUCTIONS]

    You have been provided an output which may contain mistaken transcriptions. When possible, match the transcriptions to the contextual data, to make sure they make sense:
    [
        "IBE292": {
            "status": [alt, head, speed, lat, long],
            "last_instruction": "CLIMB 35000",
            "last_instruction_successful": True,
        }
    ]
    
\end{lstlisting}
(ADD IMPLEMENTATION TO APPENDIX)